import jsPDF from 'jspdf'

class PDFService {
  constructor() {
    this.doc = null
    this.currentY = 30
    this.pageHeight = 270
    this.margins = {
      left: 25,
      right: 25,
      top: 30,
      bottom: 30
    }
    this.pageWidth = 160 // A4 width minus margins
    this.tocItems = []
    this.currentPageNumber = 1
  }

  createPDF(reportData) {
    this.doc = new jsPDF()
    this.currentY = 30
    this.tocItems = []
    this.currentPageNumber = 1

    // Add header with title and metadata on first page
    this.addHeader(reportData)
    
    // Add abstract/executive summary
    this.addAbstract(reportData)
    
    // Add main content
    this.addMainContent(reportData)
    
    // Add references (sources)
    if (reportData.sources && reportData.sources.length > 0) {
      this.addReferences(reportData.sources)
    }
    
    // Add appendices
    this.addAppendices(reportData)

    // Add page numbers to all pages
    this.addPageNumbers()

    return this.doc
  }

  addHeader(reportData) {
    // Main title - academic style
    this.doc.setFontSize(18)
    this.doc.setFont('times', 'bold')
    const title = 'Shallow Research Report'
    this.doc.text(title, this.pageWidth / 2 + this.margins.left, this.currentY, { align: 'center' })
    this.currentY += 12

    // Subtitle with the claim
    this.doc.setFontSize(14)
    this.doc.setFont('times', 'normal')
    const claimLines = this.doc.splitTextToSize(reportData.originalClaim || 'Research Analysis', this.pageWidth - 20)
    claimLines.forEach(line => {
      this.doc.text(line, this.pageWidth / 2 + this.margins.left, this.currentY, { align: 'center' })
      this.currentY += 7
    })
    this.currentY += 5

    // Author and date info - academic style
    this.doc.setFontSize(11)
    this.doc.setFont('times', 'italic')
    this.doc.text('Generated by itLooksLegit.com', this.pageWidth / 2 + this.margins.left, this.currentY, { align: 'center' })
    this.currentY += 6
    this.doc.text(this.formatDate(reportData.created_at), this.pageWidth / 2 + this.margins.left, this.currentY, { align: 'center' })
    this.currentY += 15

    // Add horizontal line separator
    this.doc.setLineWidth(0.5)
    this.doc.line(this.margins.left, this.currentY, this.margins.left + this.pageWidth, this.currentY)
    this.currentY += 10
  }

  addAbstract(reportData) {
    // Abstract section
    this.doc.setFontSize(12)
    this.doc.setFont('times', 'bold')
    this.doc.text('Abstract', this.margins.left, this.currentY)
    this.currentY += 8

    this.doc.setFontSize(10)
    this.doc.setFont('times', 'normal')
    
    // Extract first paragraph or create abstract from summary
    const abstractText = this.extractAbstract(reportData.summary)
    const abstractLines = this.doc.splitTextToSize(abstractText, this.pageWidth)
    
    abstractLines.forEach(line => {
      if (this.currentY > this.pageHeight) {
        this.addNewPage()
      }
      this.doc.text(line, this.margins.left, this.currentY)
      this.currentY += 5
    })
    this.currentY += 10
  }

  extractAbstract(summary) {
    if (!summary) return 'This report provides a comprehensive fact-check analysis of the given claim using AI-powered research and verification methods.'
    
    // Get first paragraph or first 200 characters
    const firstParagraph = summary.split('\n\n')[0] || summary.substring(0, 300)
    return this.cleanMarkdown(firstParagraph) + '...'
  }

  addMainContent(reportData) {
    if (reportData.summary) {
      // Parse markdown-like content for headings
      const content = this.cleanMarkdown(reportData.summary)
      const lines = content.split('\n')
      
      for (const line of lines) {
        if (this.currentY > this.pageHeight) {
          this.addNewPage()
        }

        if (line.startsWith('## ')) {
          // H2 heading - academic style
          this.currentY += 5 // Extra space before headings
          this.doc.setFontSize(12)
          this.doc.setFont('times', 'bold')
          const headingText = line.substring(3).trim()
          this.doc.text(headingText, this.margins.left, this.currentY)
          this.currentY += 8
          
          // Add subtle underline
          this.doc.setLineWidth(0.3)
          this.doc.line(this.margins.left, this.currentY - 2, this.margins.left + this.doc.getTextWidth(headingText) + 10, this.currentY - 2)
          this.currentY += 3
        } else if (line.startsWith('### ')) {
          // H3 heading
          this.currentY += 3
          this.doc.setFontSize(11)
          this.doc.setFont('times', 'bold')
          this.doc.text(line.substring(4), this.margins.left + 5, this.currentY)
          this.currentY += 7
        } else if (line.trim() !== '') {
          // Regular paragraph - justified text
          this.doc.setFontSize(10)
          this.doc.setFont('times', 'normal')
          const textLines = this.doc.splitTextToSize(line, this.pageWidth)
          
          for (let i = 0; i < textLines.length; i++) {
            if (this.currentY > this.pageHeight) {
              this.addNewPage()
            }
            
            const textLine = textLines[i]
            // Justify text except for last line of paragraph
            if (i < textLines.length - 1 && textLine.length > this.pageWidth * 0.7) {
              this.justifyText(textLine, this.margins.left, this.currentY, this.pageWidth)
            } else {
              this.doc.text(textLine, this.margins.left, this.currentY)
            }
            this.currentY += 5
          }
          this.currentY += 3 // Space between paragraphs
        }
      }
    }
  }

  justifyText(text, x, y, width) {
    const words = text.split(' ')
    if (words.length <= 1) {
      this.doc.text(text, x, y)
      return
    }

    const textWidth = this.doc.getTextWidth(text)
    const spaces = words.length - 1
    const extraSpace = (width - textWidth) / spaces

    let currentX = x
    for (let i = 0; i < words.length; i++) {
      this.doc.text(words[i], currentX, y)
      currentX += this.doc.getTextWidth(words[i])
      if (i < words.length - 1) {
        currentX += this.doc.getTextWidth(' ') + extraSpace
      }
    }
  }

  addReferences(sources) {
    this.addAcademicSection('References')
    
    this.doc.setFontSize(9)
    this.doc.setFont('times', 'normal')

    sources.forEach((source, index) => {
      if (this.currentY > this.pageHeight - 20) {
        this.addNewPage()
      }

      // Academic reference format: [1] Author. Title. URL. (Date).
      const refText = `[${index + 1}] ${source.title || 'Untitled'}. Available at: ${source.url}`
      const refLines = this.doc.splitTextToSize(refText, this.pageWidth - 10)
      
      // Hanging indent for references
      refLines.forEach((line, lineIndex) => {
        const indent = lineIndex === 0 ? 0 : 15
        this.doc.text(line, this.margins.left + indent, this.currentY)
        this.currentY += 5
      })
      this.currentY += 3
    })
  }

  addAppendices(reportData) {
    // Add limitations as Appendix A
    if (reportData.limitations && reportData.limitations.length > 0) {
      this.addAcademicSection('Appendix A: Limitations')
      
      this.doc.setFontSize(10)
      this.doc.setFont('times', 'normal')

      reportData.limitations.forEach((limitation, index) => {
        if (this.currentY > this.pageHeight - 15) {
          this.addNewPage()
        }

        this.doc.text(`${index + 1}.`, this.margins.left, this.currentY)
        const limitationLines = this.doc.splitTextToSize(limitation, this.pageWidth - 15)
        limitationLines.forEach((line, lineIndex) => {
          const indent = lineIndex === 0 ? 15 : 20
          this.doc.text(line, this.margins.left + indent, this.currentY)
          this.currentY += 5
        })
        this.currentY += 3
      })
    }

    // Add recommendations as Appendix B
    if (reportData.recommendations && reportData.recommendations.length > 0) {
      this.addAcademicSection('Appendix B: Recommendations')
      
      this.doc.setFontSize(10)
      this.doc.setFont('times', 'normal')

      reportData.recommendations.forEach((recommendation, index) => {
        if (this.currentY > this.pageHeight - 15) {
          this.addNewPage()
        }

        this.doc.text(`${index + 1}.`, this.margins.left, this.currentY)
        const recLines = this.doc.splitTextToSize(recommendation, this.pageWidth - 15)
        recLines.forEach((line, lineIndex) => {
          const indent = lineIndex === 0 ? 15 : 20
          this.doc.text(line, this.margins.left + indent, this.currentY)
          this.currentY += 5
        })
        this.currentY += 3
      })
    }
  }

  addAcademicSection(title) {
    if (this.currentY > this.pageHeight - 30) {
      this.addNewPage()
    }

    this.currentY += 8 // Extra space before major sections
    this.doc.setFontSize(12)
    this.doc.setFont('times', 'bold')
    this.doc.text(title, this.margins.left, this.currentY)
    this.currentY += 10

    // Add professional underline
    this.doc.setLineWidth(0.8)
    this.doc.line(this.margins.left, this.currentY - 3, this.margins.left + this.pageWidth, this.currentY - 3)
    this.currentY += 5
  }

  addPageNumbers() {
    const totalPages = this.doc.internal.getNumberOfPages()
    
    for (let i = 1; i <= totalPages; i++) {
      this.doc.setPage(i)
      this.doc.setFontSize(9)
      this.doc.setFont('times', 'normal')
      
      // Page number at bottom center
      const pageText = `${i}`
      const pageWidth = this.doc.internal.pageSize.width
      this.doc.text(pageText, pageWidth / 2, this.doc.internal.pageSize.height - 15, { align: 'center' })
      
      // Add footer line
      this.doc.setLineWidth(0.3)
      this.doc.line(this.margins.left, this.doc.internal.pageSize.height - 25, 
                   pageWidth - this.margins.right, this.doc.internal.pageSize.height - 25)
    }
  }

  addNewPage() {
    this.doc.addPage()
    this.currentY = this.margins.top
    this.currentPageNumber++
  }

  cleanMarkdown(text) {
    if (!text) return ''
    
    // Remove markdown links but keep the text
    return text
      .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
      .replace(/\*\*(.*?)\*\*/g, '$1')
      .replace(/\*(.*?)\*/g, '$1')
      .replace(/`([^`]+)`/g, '$1')
  }

  formatDate(dateString) {
    if (!dateString) return new Date().toLocaleDateString()
    return new Date(dateString).toLocaleDateString()
  }

  downloadPDF(filename = 'research-report.pdf') {
    if (this.doc) {
      this.doc.save(filename)
    }
  }
}

export default new PDFService()